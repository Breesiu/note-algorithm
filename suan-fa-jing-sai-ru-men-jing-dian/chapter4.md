# 第四章 函数与递归

* 建议把谓词命名为is\_xxx的形式，返回int值，0表示false,1表示true
* 函数调用栈保存了该函数的返回地址和局部变量，这样自然的保证了不同函数间的局部变量互不相干
* 数组作为函数参数时，int a\[\]和int\* a的作用是一样的，均不能对函数参数机型sizeof\(a\)运算，得到的只是指针类型的宽度，而应该传入指针，并且传入数组的宽度，当然也可以从第二位传入，如int &a\[1\]
* 函数作为函数参数，用的最多的就是sort函数传入cmp参数，这里cmp是函数名，即函数指针，函数的入口地址。
* 由于使用了调用栈，c语言自然支持递归，并且调用自己和调用其他函数没有本质区别，都是建立栈帧，传递参数并修改当前代码行
* 段错误和段溢出，size命令可以得到可执行文件各个段的大小，包括正文段（存储指令）、数据段（存储已初始化的全局变量）、BSS段（用来存储未赋值的全局变量所需的空间）。
* 运行时程序才常见堆栈段，里面存放着调用栈，保存着函数的调用关系和局部变量，所以，如果发生段溢出，可能是递归深度的问题，当然也可能是局部变量太大的原因，所以建议把大数组写到main函数外面。
* 不要返回局部变量的指针，因为局部变量存储在系统栈中，函数调用解释自动释放该内存，如果要返回新变量的指针，应该用malloc动态内存分配。
* 浮点数误差：判断浮点数相等可以用相差为1e-6来判断

