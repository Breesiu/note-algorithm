# 第三章：出类拔萃-中级篇

## 3.1 二分搜索

* lower\_bound
* 假定一个解并判断是否可行
* POJ 1064 Cable Master

有N条绳子，它们的长度分别为Li。如果从他们中切割出K条长度相同的绳子的话，这K条绳子每条能有多长？答案保留小数点后两位。

用二分法来判断中间的解是否可行，然后缩小解区间。

* 最大化最小值
* POJ 2456 Aggressive cows

有N间牛舍的小屋。牛舍排在一条直线上，第i号牛舍在xi的位置。有m头牛，将每头牛都放在离其他牛就可能远的牛舍。也就是要最大化最近的两头牛之间的距离。

依然用二分法来判断中间的解是否可行，判断的时候采用贪心法，首先对牛舍的位置排序，然后第一头牛放x0，如果第i头牛放xj的话，那么的i+1头牛就要放入满足xj+d&lt;=xk的最小的xk中。

* 最大化平均值
* 有n个物品的重量和价值分别是wi和vi。从中选出k个物品使得单位重量的价值最大。

例：n=3;k=2;\(w,v\)={\(2,2\),\(5,3\),\(2,1\)} 选0和2号物品，平均价值是0.75。

如果把物品按照单位价值进行排序，从小到大贪心的进行选取，可以从示例看到该方法是不对的。

实际上用二分法可以很好解决。

$\sum{v\_i}/\sum{w\_i}&gt;=x$ 即 $\sum\(v\_i-x_w\_i\)&gt;=0$，因此，可以对 $\(v\_i-x_w\_i\)$的值进行排序贪心的进行选取，使得其前k个数的和不小于0。每次判断的复杂度是O\(nlogn\)，即为排序的复杂度。

## 3.2 常用技巧精选一

* 尺取法
* POJ 3061 Subsequence

给出长度为n的整数数列，求出总和不小于S的连续子序列的长度的最小值。如果解不存在，输出0.

尺取法也可以说是双指针法，反复的推进区间的开头和末尾，来求取满足条件的最小区间的方法。

* 反转（开关问题）
* POJ 3276 Face The Right Way

N头牛排成一列，每头牛朝向为前或后，为了让所有的牛都朝向前方，转牛机在购买时必须设定一个数值k，机器每操作一次恰好使K头连续的牛转向。请求出为了让所有的牛都面向前方需要的最少的操作次数M和对应的最小的K。

首先我们考虑对于一个特定的K，如何求出让所有的牛面朝前方的最小操作次数。可以看到交换区间翻转的顺序对结果没有影响，对一个区间进行两次以上的翻转是多余的。于是考虑最左端的牛，包含这个牛的区间只有一个，如果这头牛面朝前方，我们就知道这个区间不需要翻转。如果朝后，对应的区间就必须进行翻转了。而且此后，这个最左的区间就不需要考虑了，问题的规模就缩小了1.

我们需要对所有的K都求解一次，每次固定K时，要从左到右考虑N头牛，此时最坏情况下需要进行N-K+1次的翻转操作，而每次翻转操作又要翻转K头牛，于是总的复杂度是O\(N^3\)。这样的话不足以在时限内解决问题，但是区间翻转的部分是很容易进行优化的。

f\[i\]:=区间\[i,i+K-1\]进行了翻转则为1，否则为0

这样，在考虑第i头牛的时候，如果 $\sum\_{j=i+K-1}^{i-1}f\[i\]$ 为奇数的话，则这头牛的方向与起始方向相反，否则方向不变。并且该式可以在常数时间内更新，复杂度就变成了O\(N^2\)。

* POJ 3279 Fliptile

反转黑白棋，棋盘大小为M\*N，游戏要做的就是把所有的格子翻转为白色。不同的在于每次翻转时，与该格子相邻的上下左右的四个格子也会被翻转。通过尽可能少的步数将所有的格子翻转为白色，解不存在时输出IMPOSSIBLE。

如果确定了第一行的反转方式，那么，第二行及以后的反转方式都可以确定，就可以求出整个问题的最小步数，该算法最上面的一行的反转次数为 2^N 种，复杂度为 $O\(MN2^N\)$

* 折半搜索
* POJ 2785 4 Values whose Sum is 0

给定各有n个整数的四个数列A、B、C、D。要从数列中各取出1个数，使四个数的和为0.求出这样的组合的个数。当一个数列中有多个相同的数字时，把他们作为不同的数字看待。

暴力方法 n^4 不行，先将他们对半分成AB和CD再考虑，从两个数列中选择只有 n^2 种组合，所以可以进行枚举，枚举后将这些和排好序，再二分搜索。总的复杂度是 $O\(n^2 logn\)$

* 超大背包问题

有重量和价值分别为wi、vi的n个物品。从这些物品中挑选总重量不超过W的物品，求所有挑选方案中价值总和的最大值。

1&lt;=n&lt;=40

1&lt;= wi,vi &lt;=10^15

1&lt;= W&lt;= 10^15

这个背包问题的特点在于价值和数量都是非常大的数值，相比之下n很小。使用DP背包问题的复杂度是O\(nW\)，因此不能用来解决这里的问题。

因为挑选物品的方法总共有 2^n 种，所以不能直接枚举，但是像前面一样拆成两半之后再枚举的话，因为每部分只有20个还是可行的。这样在前半部分的选取方法中对应的重量和价值即为w1、v1。在后半部分中寻找max{v2\|w2&lt;=W-w1}。

首先需要排除所有 w2\[i\]&lt;=w2\[j\] 且 v2\[i\]&gt;=v2\[j\] 的 j 。**这一点可以按照 w2、v2的字典序排序后简单做到**。要计算 max{v2\|w2&lt;=W-w1} 的话，只要寻找满足 w2\[i\]&lt;=W-w1 的最大的i就可以了。这个过程可以用二分完成，总个数为M的话（M&lt;=2^\(n/2\)），一次搜索需要 O\(logM\) 的时间。所以总的复杂度为 O\(2^\(n/2\) \* n\)，可以在时限内解决这个问题。

* 坐标离散化

w\*h 的格子上花了n条或垂直或水平的宽度为1的直线。求出这些线将格子划分成了多少个区域。

1 &lt;= w,h &lt;= 1000000

1 &lt;= n &lt;= 500

准备好w_h的数组，并记录是否有直线通过，然后参考DFS求连通域的方法，可以求出被分隔的区域个数。但是这个问题中w和h的最大为1000000，所以没办法创建w_h的数组。因此用坐标离散化这个技巧。

请参考书中图示，离散化代码如下。

```cpp
//对x1和x2进行离散化，并返回离散化之后的宽度
int compress(int *x1 ,int *x2,int w){
    vector<int> xs;
    for (int i=0;i<N;i++){//N指有n条线段，每个线段两个坐标点
        for(int d=-1;d<=1;d++){
            int tx1 = x1[i]+d,tx2 = x2[i]+d;
            if(1 <= tx1 && tx1 <= W) xs.push(tx1)
            if(1 <= tx2 && tx2 <= W) xs.push(tx2)
        }
    }
    sort(xs.begin(),xs.end());
    xs.erase(unique(xs.begin(),xs.end()),xs.end());
    //unique的返回值是尾指针的位置

    for(int i=0;i<=M;i++){
        x1[i] = find(xs.begin(),xs.end(),x1[i])-xs.begin();
        x2[i] = find(xs.begin(),xs.end(),x2[i])-xs.begin();
    }

    return xs.size();
}
```

> 感觉这个离散化的过程和实际不太符合！！！！

## 3.3 活用各种数据结构

### 3.3.1 线段树

线段树善于处理区间问题，形式上是一颗完美二叉树，用向量存储，书中的每个节点维护一个区间。根节点维护的是整个区间，每个节点维护的是父节点的区间二等分后的其中一个区间。

RMQ（Range Minimum Query）操作的线段树主要涉及两种操作：

* 求区间最小值
* 修改指定元素的数值

两种操作的复杂度都是O\(N\)

要求某个区间的最小值，像下面这样递归处理就好了。

* 如果所查询的区间和当前节点对应的区间完全没有交集，那么就返回一个不影响答案的值（比如INT\_MAX）
* 如果所查询的区间完全包含了当前节点对应的区间，那么就返回当前节点的值
* 以上两种情况都不满足的话，就对两个儿子区间递归处理，返回两个结果中的较小值

线段树的初始化的复杂度是O\(N\)，和完全二叉堆的初始化过程类似。

```cpp
const int MAX_N = 1<<17;

//存储线段树的全局数组
int n,dat[2*MAAX_N-1];

//初始化
void init(int n_){
    //为了简单起见，把元素个数扩大到2的幂
    n=1;
    while(n<n_)n*=2;

    //把所有的值都设定为INT_MAX
    for(int i=0;i<2*n-1;i++)dat[i]=INT_MAX;
}

//把第k(0-(n-1))个值更新为a
void update(int k,int a){
    k+=n-1;
    dat[k]=a;
    //向上更新
    while(k>0){
        k=(k-1)/2;
        dat[k]=min(dat[k*2+1],dast[k*2+2]);
    }
}

//求[a,b)的最小值
//后面的参数是为了计算起来方便传入的
//k是节点的编号，l，r表示这个节点对应的[l,r)区间
//在外部调用时，用query(a,b,0,0,n)
int query(int a,int b,int k,int l,int r){
    //不相交
    if(r<=a||b<=l)return INT_MAX;
    //区间包含
    if(a<=l&&r<=b)return dat[k];
    else{
        int vl = query(a,b,k*2+1,l,(l+r)/2)
        int vr = query(a,b,k*2+2,(l+r)/2,r)
        return min(vl,vr);
    }
}
```

POJ 2991 Crane

每个节点表示一段连续的线段的集合，并且维护下面两个值。

* 把对应的线段集合中的第一条线段转至垂直方向之后，从第一条线段的起点指向最后一条线段的终点的向量。
* （如果该节点有儿子节点）两个儿子节点对应的部分连接之后，右儿子需要转动的角度。

待续

### 3.3.2 Binary Indexed Tree

### 3.3.3 分桶法和平方分割

## 3.4 熟练掌握动态规划

### 3.4.1 状态压缩DP

### 3.4.2 矩阵的幂

### 3.4.3 利用数据结构高效求解

## 3.5 借助水流解决问题的网络流

### 3.5.1 最大流

### 3.5.2 最小割

### 3.5.3 二分图匹配

### 3.5.4 一般图匹配

### 3.5.5 匹配、边覆盖、独立集和顶点覆盖

### 3.5.6 最小费用流

## 3.6与平面和空间打交道的计算几何

